# Методи **string**

## \` `
1. Зворотні лапки дозволяють ${…}
2. Дозволяють рядку охоплювати кілька ліній:
```
let guestList = `Гості:
  Іван
  Петро
  Марія
`;

alert(guestList); // список гостей в кілька рядків
```

## Доступ до символів
```
let str = `Привіт`;

alert( str[0] ); // П
alert( str.charAt(0) ); // П

alert( str[str.length - 1] ); // т
alert( str.at(-1) );
```
`str[0]` - це сучасний синтаксис для доступу до символу за індексом, який працює в JavaScript.
<br>
`str.charAt(0)` - це старий метод, який також працює в JavaScript, але вважається застарілим.
<br>
`str[str.length - 1]` - це традиційний спосіб отримати останній символ рядка, шляхом доступу до символу за індексом, який дорівнює довжині рядка мінус 1.
<br>
`str.at(-1)` - це новий метод, який був введений у ES2022 (ECMAScript 2022). Він дозволяє отримувати символи з кінця рядка, використовуючи негативні індекси. 
<br>
#### У сучасному коді рекомендується використовувати `str[0]` для доступу до першого символу та `str.at(-1)` для доступу до останнього символу, оскільки ці варіанти є більш лаконічними та зрозумілими. 

## Пошук підрядка
### ❗ пошук чутливий до регістру
1. `str.indexOf(substr, pos?)` ➡ 1(підрядок знайдено на позиції) : -1 (збігів не знайдено). Аргумент **pos** дозволяє нам почати пошук із заданої позиції.
2. `str.lastIndexOf(substr, pos?)` у зворотному порядку
3. `str.includes(substr, pos?)` ➡ true : false
4. `startsWith(substr, pos?)` ➡ true : false
5. `endsWith(substr, pos?)` ➡ true : false

## Отримання підрядка 
1. `str.slice(indexStart, indexEnd?)` (не включно end). ⭕Відʼємні аргументи підтримуються.
```
             indexStart        indexEnd
                  ↓               ↓
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| T | h | e |   | m | i | r | r | o | r |

                  m   i   r   r
                 _______________
                      ↑
                    Result
```
2. `str.substring(indexStart, indexEnd?)` (не включно end) <br> дозволяє задати start більше ніж end (у цьому випадку він просто міняє значення start і end місцями). ⭕Відʼємні аргументи не підтримуються, вони інтерпретуються як 0.
3. `str.substr(start, length?)` на відміну від попередніх методів, цей дозволяє вказати довжину length замість кінцевої позиції. ⭕Дозволяє відʼємні значення start.

## Правильне порівняння string
`localeCompare(compareString, locales?, options?)`
- ➡ Повертає відʼємне число, якщо str менше, ніж str2.
- ➡ Повертає додатне число, якщо str більше, ніж str2.
- ➡ Повертає 0, якщо вони рівні.
```
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

## ❗❗❗ 
### Рядки незмінні ~~`str[0] = 'о';`~~
### Порівнюються символ за символом в алфавітному порядку
1. Літера в малому регістрі завжди більша за літеру у великому
2. Літери з діакритичними знаками “не в порядку” (`Ö` абощо..)
